#include<Windows.h>
#include<tchar.h>
#include<stdio.h>

/*

An asynchronous procedure call (APC) is a function that executes asynchronously in the context of a particular thread. When an APC is queued to a thread, the system issues a software interrupt. The next time the thread is scheduled, it will run the APC function. An APC generated by the system is called a kernel-mode APC. An APC generated by an application is called a user-mode APC. A thread must be in an alertable state to run a user-mode APC. 
异步程序调用（APC）是一个函数!!!,是一个在指定线程环境下运行的函数！！！。当一个APC函数被注入到一个线程的APC队列后，在线程下一次被调度的时候，系统会优先执行APC函数。APC分两种，系统APC和用户APC。系统产生的APC就是系统APC,应用程序产生的APC就是用户APC。用户APC执行有一个条件，就是执行APC的线程必须处于惊醒状态。


Each thread has its own APC queue. An application queues an APC to a thread by calling the QueueUserAPC function. The calling thread specifies the address of an APC function in the call to QueueUserAPC. The queuing of an APC is a request for the thread to call the APC function. 
每个线程都有自己的APC队列。将APC注入到某个指定线程的函数叫QueueUserAPC。调用QueueUserAPC函数的线程，指定APC函数的地址，指定执行APC函数的线程，被指定线程执行APC函数。

When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state. A thread enters an alertable state when it calls the SleepEx, SignalObjectAndWait, MsgWaitForMultipleObjectsEx, WaitForMultipleObjectsEx, or WaitForSingleObjectEx function. If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed. However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function. 
当一个用户APC被注入到某个线程的APC队列后，线程在下一次被调度的时候，如果线程处于惊醒状态，那么线程并不执行用户APC，如何使线程进入警醒状态呢？SleepEx，WaitForSingleObjectEx,waitForMultipleObjectsEx,SignalObjectAndWait。

Note that the ReadFileEx, SetWaitableTimer, and WriteFileEx functions are implemented using an APC as the completion notification callback mechanism. 
注意，ReadFileEx，SetWaitableTimer，WriteFileEx函数使用APC进行完成通知。

Synchronization Internals 
When an I/O request is issued, a structure is allocated to represent the request. This structure is called an I/O request packet (IRP). With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete. With asynchronous I/O, the thread builds the IRP and sends it to the device stack. The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress. When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as CancelIo. In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP. 


There are several ways that the system can indicate that the IRP has completed:

Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.
Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.
Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.
Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.
Threads that wait on an I/O completion port do not wait in an alertable state. Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.

See Also 


*/

VOID CALLBACK APCProc(
  __in  ULONG_PTR dwParam
)
{
	_tprintf(L"This Apc has been running = %d\n",GetCurrentThreadId());
	return;
}


void abc()
{
	SleepEx(INFINITE,TRUE);
}

DWORD WINAPI Thread(PVOID)
{
	while(1)
	{
		SleepEx(INFINITE,TRUE);
	}
	return 0;
}


int _tmain()
{

	_tprintf(L"CurrentThreadId = %d APC = %d\n",GetCurrentThreadId(),APCProc);
	//HANDLE h=CreateThread(NULL,0,Thread,NULL,0,NULL);
	//QueueUserAPC(APCProc,h,NULL);
	//abc();
	SleepEx(INFINITE,TRUE);

	_gettchar();
	return 0;

}

/*
1. 



*/